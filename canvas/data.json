{"graph": [], "multigraph": false, "links": [{"source": 0, "target": 38}, {"source": 1, "target": 38}, {"source": 2, "target": 38}, {"source": 3, "target": 38}, {"source": 4, "target": 38}, {"source": 5, "target": 38}, {"source": 6, "target": 38}, {"source": 7, "target": 31}, {"source": 7, "target": 14}, {"source": 7, "target": 35}, {"source": 7, "target": 38}, {"source": 7, "target": 84}, {"source": 7, "target": 94}, {"source": 7, "target": 124}, {"source": 7, "target": 147}, {"source": 8, "target": 38}, {"source": 9, "target": 38}, {"source": 10, "target": 38}, {"source": 11, "target": 38}, {"source": 12, "target": 38}, {"source": 13, "target": 38}, {"source": 14, "target": 38}, {"source": 14, "target": 143}, {"source": 14, "target": 99}, {"source": 14, "target": 108}, {"source": 14, "target": 58}, {"source": 15, "target": 38}, {"source": 15, "target": 152}, {"source": 16, "target": 38}, {"source": 17, "target": 38}, {"source": 17, "target": 152}, {"source": 17, "target": 55}, {"source": 17, "target": 81}, {"source": 18, "target": 38}, {"source": 19, "target": 38}, {"source": 20, "target": 38}, {"source": 20, "target": 152}, {"source": 21, "target": 38}, {"source": 22, "target": 38}, {"source": 22, "target": 70}, {"source": 23, "target": 38}, {"source": 24, "target": 38}, {"source": 25, "target": 38}, {"source": 25, "target": 152}, {"source": 26, "target": 38}, {"source": 27, "target": 38}, {"source": 28, "target": 38}, {"source": 29, "target": 158}, {"source": 29, "target": 38}, {"source": 30, "target": 38}, {"source": 31, "target": 38}, {"source": 31, "target": 143}, {"source": 31, "target": 99}, {"source": 31, "target": 108}, {"source": 31, "target": 58}, {"source": 32, "target": 38}, {"source": 33, "target": 38}, {"source": 33, "target": 152}, {"source": 34, "target": 38}, {"source": 35, "target": 58}, {"source": 35, "target": 143}, {"source": 35, "target": 99}, {"source": 35, "target": 108}, {"source": 35, "target": 152}, {"source": 36, "target": 38}, {"source": 37, "target": 38}, {"source": 38, "target": 39}, {"source": 38, "target": 40}, {"source": 38, "target": 41}, {"source": 38, "target": 42}, {"source": 38, "target": 43}, {"source": 38, "target": 44}, {"source": 38, "target": 45}, {"source": 38, "target": 46}, {"source": 38, "target": 47}, {"source": 38, "target": 48}, {"source": 38, "target": 49}, {"source": 38, "target": 50}, {"source": 38, "target": 51}, {"source": 38, "target": 52}, {"source": 38, "target": 53}, {"source": 38, "target": 54}, {"source": 38, "target": 55}, {"source": 38, "target": 56}, {"source": 38, "target": 57}, {"source": 38, "target": 58}, {"source": 38, "target": 59}, {"source": 38, "target": 60}, {"source": 38, "target": 61}, {"source": 38, "target": 88}, {"source": 38, "target": 63}, {"source": 38, "target": 64}, {"source": 38, "target": 65}, {"source": 38, "target": 167}, {"source": 38, "target": 66}, {"source": 38, "target": 67}, {"source": 38, "target": 68}, {"source": 38, "target": 69}, {"source": 38, "target": 70}, {"source": 38, "target": 71}, {"source": 38, "target": 72}, {"source": 38, "target": 73}, {"source": 38, "target": 74}, {"source": 38, "target": 75}, {"source": 38, "target": 76}, {"source": 38, "target": 77}, {"source": 38, "target": 78}, {"source": 38, "target": 79}, {"source": 38, "target": 80}, {"source": 38, "target": 81}, {"source": 38, "target": 82}, {"source": 38, "target": 83}, {"source": 38, "target": 84}, {"source": 38, "target": 85}, {"source": 38, "target": 87}, {"source": 38, "target": 62}, {"source": 38, "target": 89}, {"source": 38, "target": 90}, {"source": 38, "target": 91}, {"source": 38, "target": 92}, {"source": 38, "target": 93}, {"source": 38, "target": 94}, {"source": 38, "target": 95}, {"source": 38, "target": 96}, {"source": 38, "target": 97}, {"source": 38, "target": 98}, {"source": 38, "target": 99}, {"source": 38, "target": 100}, {"source": 38, "target": 101}, {"source": 38, "target": 102}, {"source": 38, "target": 103}, {"source": 38, "target": 104}, {"source": 38, "target": 105}, {"source": 38, "target": 106}, {"source": 38, "target": 107}, {"source": 38, "target": 108}, {"source": 38, "target": 109}, {"source": 38, "target": 110}, {"source": 38, "target": 111}, {"source": 38, "target": 112}, {"source": 38, "target": 113}, {"source": 38, "target": 115}, {"source": 38, "target": 116}, {"source": 38, "target": 118}, {"source": 38, "target": 119}, {"source": 38, "target": 120}, {"source": 38, "target": 121}, {"source": 38, "target": 122}, {"source": 38, "target": 123}, {"source": 38, "target": 124}, {"source": 38, "target": 125}, {"source": 38, "target": 126}, {"source": 38, "target": 127}, {"source": 38, "target": 128}, {"source": 38, "target": 129}, {"source": 38, "target": 130}, {"source": 38, "target": 131}, {"source": 38, "target": 132}, {"source": 38, "target": 133}, {"source": 38, "target": 143}, {"source": 38, "target": 134}, {"source": 38, "target": 135}, {"source": 38, "target": 136}, {"source": 38, "target": 137}, {"source": 38, "target": 138}, {"source": 38, "target": 139}, {"source": 38, "target": 140}, {"source": 38, "target": 141}, {"source": 38, "target": 142}, {"source": 38, "target": 144}, {"source": 38, "target": 145}, {"source": 38, "target": 146}, {"source": 38, "target": 147}, {"source": 38, "target": 148}, {"source": 38, "target": 149}, {"source": 38, "target": 150}, {"source": 38, "target": 151}, {"source": 38, "target": 152}, {"source": 38, "target": 153}, {"source": 38, "target": 154}, {"source": 38, "target": 155}, {"source": 38, "target": 156}, {"source": 38, "target": 157}, {"source": 38, "target": 158}, {"source": 38, "target": 159}, {"source": 38, "target": 160}, {"source": 38, "target": 161}, {"source": 38, "target": 162}, {"source": 38, "target": 163}, {"source": 38, "target": 164}, {"source": 38, "target": 165}, {"source": 38, "target": 166}, {"source": 38, "target": 86}, {"source": 38, "target": 168}, {"source": 38, "target": 169}, {"source": 38, "target": 170}, {"source": 38, "target": 171}, {"source": 38, "target": 172}, {"source": 38, "target": 173}, {"source": 38, "target": 174}, {"source": 38, "target": 175}, {"source": 38, "target": 176}, {"source": 38, "target": 177}, {"source": 38, "target": 178}, {"source": 38, "target": 179}, {"source": 38, "target": 180}, {"source": 38, "target": 181}, {"source": 38, "target": 182}, {"source": 38, "target": 183}, {"source": 38, "target": 184}, {"source": 38, "target": 185}, {"source": 38, "target": 114}, {"source": 41, "target": 123}, {"source": 46, "target": 142}, {"source": 49, "target": 111}, {"source": 50, "target": 136}, {"source": 50, "target": 175}, {"source": 50, "target": 152}, {"source": 55, "target": 81}, {"source": 55, "target": 129}, {"source": 55, "target": 152}, {"source": 57, "target": 152}, {"source": 58, "target": 84}, {"source": 58, "target": 94}, {"source": 58, "target": 124}, {"source": 58, "target": 147}, {"source": 59, "target": 150}, {"source": 61, "target": 161}, {"source": 62, "target": 152}, {"source": 74, "target": 140}, {"source": 74, "target": 152}, {"source": 75, "target": 171}, {"source": 79, "target": 128}, {"source": 79, "target": 152}, {"source": 81, "target": 152}, {"source": 84, "target": 143}, {"source": 84, "target": 99}, {"source": 84, "target": 108}, {"source": 92, "target": 183}, {"source": 94, "target": 143}, {"source": 94, "target": 99}, {"source": 94, "target": 108}, {"source": 94, "target": 152}, {"source": 95, "target": 150}, {"source": 99, "target": 124}, {"source": 99, "target": 147}, {"source": 100, "target": 152}, {"source": 105, "target": 152}, {"source": 108, "target": 124}, {"source": 108, "target": 147}, {"source": 117, "target": 127}, {"source": 123, "target": 142}, {"source": 124, "target": 143}, {"source": 127, "target": 152}, {"source": 129, "target": 152}, {"source": 136, "target": 178}, {"source": 136, "target": 175}, {"source": 142, "target": 185}, {"source": 143, "target": 147}, {"source": 150, "target": 151}, {"source": 152, "target": 163}, {"source": 152, "target": 173}, {"source": 152, "target": 166}, {"source": 152, "target": 175}, {"source": 152, "target": 172}, {"source": 152, "target": 183}, {"source": 152, "target": 179}, {"source": 161, "target": 164}, {"source": 161, "target": 178}], "directed": false, "nodes": [{"color": "#a15d00", "name": "test_binary", "size": 4.732050807568877, "docstring": "None", "id": "test_binary", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/tests/test_binary.py", "type": "module"}, {"color": "#56a800", "name": "degree_alg", "size": 5.449489742783178, "docstring": "Degree centrality measures.", "id": "degree_alg", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/degree_alg.py", "type": "module"}, {"color": "#54aa00", "name": "connected", "size": 5.449489742783178, "docstring": "Connected components.", "id": "connected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/connected.py", "type": "module"}, {"color": "#619d00", "name": "test_dominance", "size": 6.741657386773941, "docstring": "None", "id": "test_dominance", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_dominance.py", "type": "module"}, {"color": "#3cc200", "name": "mis", "size": 5.449489742783178, "docstring": "Algorithm to find a maximal (not maximum) independent set.", "id": "mis", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/mis.py", "type": "module"}, {"color": "#8e7000", "name": "dag", "size": 9.0, "docstring": "None", "id": "dag", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/dag.py", "type": "module"}, {"color": "#8d7100", "name": "test_weighted", "size": 5.82842712474619, "docstring": "None", "id": "test_weighted", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/tests/test_weighted.py", "type": "module"}, {"color": "#00ff00", "name": "test_clique", "size": 5.0, "docstring": "None", "id": "test_clique", "impno": 8, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_clique.py", "type": "module"}, {"color": "#5ea000", "name": "test_branchings", "size": 5.645751311064591, "docstring": "None", "id": "test_branchings", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tree/tests/test_branchings.py", "type": "module"}, {"color": "#59a500", "name": "distance_measures", "size": 6.741657386773941, "docstring": "Graph diameter, radius, eccentricity and other properties.", "id": "distance_measures", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/distance_measures.py", "type": "module"}, {"color": "#00ff00", "name": "test_spectral_bipartivity", "size": 4.414213562373095, "docstring": "None", "id": "test_spectral_bipartivity", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_spectral_bipartivity.py", "type": "module"}, {"color": "#6a9400", "name": "test_semiconnected", "size": 5.0, "docstring": "None", "id": "test_semiconnected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/tests/test_semiconnected.py", "type": "module"}, {"color": "#897500", "name": "test_cuts", "size": 9.32455532033676, "docstring": "None", "id": "test_cuts", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/tests/test_cuts.py", "type": "module"}, {"color": "#877700", "name": "test_edgelist", "size": 5.0, "docstring": "Unit tests for bipartite edgelists.", "id": "test_edgelist", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_edgelist.py", "type": "module"}, {"type": "module", "color": "#a95500", "name": "matching", "size": 11.888194417315589, "id": "matching", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/matching.py", "docstring": "********\nMatching\n********"}, {"color": "#bd4100", "name": "weighted", "size": 12.327379053088816, "docstring": "Shortest path algorithms for weighed graphs.", "id": "weighted", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/weighted.py", "type": "module"}, {"color": "#00ff00", "name": "test_unary", "size": 4.0, "docstring": "None", "id": "test_unary", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/tests/test_unary.py", "type": "module"}, {"color": "#877700", "name": "shortestaugmentingpath", "size": 8.385164807134505, "docstring": "Shortest augmenting path algorithm for maximum flow problems.", "id": "shortestaugmentingpath", "impno": 3, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/shortestaugmentingpath.py", "type": "module"}, {"color": "#679700", "name": "mst", "size": 7.58257569495584, "docstring": "Computes minimum spanning tree of a weighted graph.", "id": "mst", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/mst.py", "type": "module"}, {"color": "#2fcf00", "name": "test_approx_clust_coeff", "size": 4.0, "docstring": "None", "id": "test_approx_clust_coeff", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_approx_clust_coeff.py", "type": "module"}, {"color": "#34ca00", "name": "semiconnected", "size": 5.0, "docstring": "Semiconnectedness.", "id": "semiconnected", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/semiconnected.py", "type": "module"}, {"color": "#5aa400", "name": "dispersion", "size": 6.0, "docstring": "None", "id": "dispersion", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/dispersion.py", "type": "module"}, {"color": "#877700", "name": "test_generators", "size": 4.732050807568877, "docstring": "None", "id": "test_generators", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_generators.py", "type": "module"}, {"color": "#7c8200", "name": "test_strongly_connected", "size": 7.58257569495584, "docstring": "None", "id": "test_strongly_connected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/tests/test_strongly_connected.py", "type": "module"}, {"color": "#807e00", "name": "test_unweighted", "size": 5.0, "docstring": "None", "id": "test_unweighted", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/tests/test_unweighted.py", "type": "module"}, {"color": "#798500", "name": "test_dag", "size": 5.645751311064591, "docstring": "None", "id": "test_dag", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_dag.py", "type": "module"}, {"color": "#00ff00", "name": "test_harmonic_centrality", "size": 6.0, "docstring": "Tests for degree centrality.", "id": "test_harmonic_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_harmonic_centrality.py", "type": "module"}, {"color": "#aa5400", "name": "test_maxflow", "size": 9.70820393249937, "docstring": "Maximum flow algorithms test suite.", "id": "test_maxflow", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/tests/test_maxflow.py", "type": "module"}, {"color": "#629c00", "name": "test_graphical", "size": 5.449489742783178, "docstring": "None", "id": "test_graphical", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_graphical.py", "type": "module"}, {"color": "#897500", "name": "greedy_coloring_with_interchange", "size": 8.65685424949238, "docstring": "None", "id": "greedy_coloring_with_interchange", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/coloring/greedy_coloring_with_interchange.py", "type": "module"}, {"color": "#7e8000", "name": "biconnected", "size": 7.69041575982343, "docstring": "Biconnected components and articulation points.", "id": "biconnected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/biconnected.py", "type": "module"}, {"type": "module", "color": "#ab5300", "name": "clique", "size": 12.055385138137417, "id": "clique", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/clique.py", "docstring": "=======\nCliques\n=======\n\nFind and manipulate cliques of graphs.\n\nNote that finding the largest clique of a graph has been\nshown to be an NP-complete problem; the algorithms here\ncould take a long time to run.\n\nhttp://en.wikipedia.org/wiki/Clique_problem"}, {"color": "#6b9300", "name": "eigenvector", "size": 7.123105625617661, "docstring": "Eigenvector centrality.", "id": "eigenvector", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/eigenvector.py", "type": "module"}, {"color": "#a15d00", "name": "capacityscaling", "size": 12.0, "docstring": "Capacity scaling minimum cost flow algorithm.", "id": "capacityscaling", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/capacityscaling.py", "type": "module"}, {"color": "#00ff00", "name": "test_distance_regular", "size": 4.0, "docstring": "None", "id": "test_distance_regular", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_distance_regular.py", "type": "module"}, {"type": "module", "color": "#2cd200", "name": "vertex_cover", "size": 5.23606797749979, "id": "vertex_cover", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/vertex_cover.py", "docstring": "************\nVertex Cover\n************\n\nGiven an undirected graph `G = (V, E)` and a function w assigning nonnegative\nweights to its vertices, find a minimum weight subset of V such that each edge\nin E is incident to at least one vertex in the subset.\n\nhttp://en.wikipedia.org/wiki/Vertex_cover"}, {"color": "#00ff00", "name": "test_mst", "size": 4.732050807568877, "docstring": "None", "id": "test_mst", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_mst.py", "type": "module"}, {"color": "#718d00", "name": "load", "size": 8.8309518948453, "docstring": "Load centrality.", "id": "load", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/load.py", "type": "module"}, {"color": "#004C00", "name": "Python", "size": 10, "id": "Python", "docstring": "Python builtin modules", "filepath": "builtin", "type": "master"}, {"color": "#00ff00", "name": "test_dominating", "size": 4.0, "docstring": "None", "id": "test_dominating", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_dominating.py", "type": "module"}, {"color": "#649a00", "name": "test_eigenvector_centrality", "size": 6.741657386773941, "docstring": "None", "id": "test_eigenvector_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_eigenvector_centrality.py", "type": "module"}, {"color": "#d32b00", "name": "isomorphvf2", "size": 16.96424004376894, "docstring": "*************\nVF2 Algorithm\n*************\n\nAn implementation of VF2 algorithm for graph ismorphism testing.\n\nThe simplest interface to use this module is to call networkx.is_isomorphic().\n\nIntroduction\n------------\n\nThe GraphMatcher and DiGraphMatcher are responsible for matching\ngraphs or directed graphs in a predetermined manner.  This\nusually means a check for an isomorphism, though other checks\nare also possible.  For example, a subgraph of one graph\ncan be checked for isomorphism to a second graph.\n\nMatching is done via syntactic feasibility. It is also possible\nto check for semantic feasibility. Feasibility, then, is defined\nas the logical AND of the two functions.\n\nTo include a semantic check, the (Di)GraphMatcher class should be\nsubclassed, and the semantic_feasibility() function should be\nredefined.  By default, the semantic feasibility function always\nreturns True.  The effect of this is that semantics are not\nconsidered in the matching of G1 and G2.\n\nExamples\n--------\n\nSuppose G1 and G2 are isomorphic graphs. Verification is as follows:\n\n>>> from networkx.algorithms import isomorphism\n>>> G1 = nx.path_graph(4)\n>>> G2 = nx.path_graph(4)\n>>> GM = isomorphism.GraphMatcher(G1,G2)\n>>> GM.is_isomorphic()\nTrue\n\nGM.mapping stores the isomorphism mapping from G1 to G2.\n\n>>> GM.mapping\n{0: 0, 1: 1, 2: 2, 3: 3}\n\n\nSuppose G1 and G2 are isomorphic directed graphs\ngraphs. Verification is as follows:\n\n>>> G1 = nx.path_graph(4, create_using=nx.DiGraph())\n>>> G2 = nx.path_graph(4, create_using=nx.DiGraph())\n>>> DiGM = isomorphism.DiGraphMatcher(G1,G2)\n>>> DiGM.is_isomorphic()\nTrue\n\nDiGM.mapping stores the isomorphism mapping from G1 to G2.\n\n>>> DiGM.mapping\n{0: 0, 1: 1, 2: 2, 3: 3}\n\n\n\nSubgraph Isomorphism\n--------------------\nGraph theory literature can be ambiguious about the meaning of the\nabove statement, and we seek to clarify it now.\n\nIn the VF2 literature, a mapping M is said to be a graph-subgraph\nisomorphism iff M is an isomorphism between G2 and a subgraph of G1.\nThus, to say that G1 and G2 are graph-subgraph isomorphic is to say\nthat a subgraph of G1 is isomorphic to G2.\n\nOther literature uses the phrase 'subgraph isomorphic' as in 'G1 does\nnot have a subgraph isomorphic to G2'.  Another use is as an in adverb\nfor isomorphic.  Thus, to say that G1 and G2 are subgraph isomorphic\nis to say that a subgraph of G1 is isomorphic to G2.\n\nFinally, the term 'subgraph' can have multiple meanings. In this\ncontext, 'subgraph' always means a 'node-induced subgraph'. Edge-induced\nsubgraph isomorphisms are not directly supported, but one should be\nable to perform the check by making use of nx.line_graph(). For\nsubgraphs which are not induced, the term 'monomorphism' is preferred\nover 'isomorphism'. Currently, it is not possible to check for\nmonomorphisms.\n\nLet G=(N,E) be a graph with a set of nodes N and set of edges E.\n\nIf G'=(N',E') is a subgraph, then:\n    N' is a subset of N\n    E' is a subset of E\n\nIf G'=(N',E') is a node-induced subgraph, then:\n    N' is a subset of N\n    E' is the subset of edges in E relating nodes in N'\n\nIf G'=(N',E') is an edge-induced subgrpah, then:\n    N' is the subset of nodes in N related by edges in E'\n    E' is a subset of E\n\nReferences\n----------\n[1]   Luigi P. Cordella, Pasquale Foggia, Carlo Sansone, Mario Vento,\n      \"A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs\",\n      IEEE Transactions on Pattern Analysis and Machine Intelligence,\n      vol. 26,  no. 10,  pp. 1367-1372,  Oct.,  2004.\n      http://ieeexplore.ieee.org/iel5/34/29305/01323804.pdf\n\n[2]   L. P. Cordella, P. Foggia, C. Sansone, M. Vento, \"An Improved\n      Algorithm for Matching Large Graphs\", 3rd IAPR-TC15 Workshop\n      on Graph-based Representations in Pattern Recognition, Cuen,\n      pp. 149-159, 2001.\n      http://amalfi.dis.unina.it/graph/db/papers/vf-algorithm.pdf\n\nSee Also\n--------\nsyntactic_feasibliity(), semantic_feasibility()\n\nNotes\n-----\nModified to handle undirected graphs.\nModified to handle multiple edges.\n\n\nIn general, this problem is NP-Complete.", "id": "isomorphvf2", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/isomorphvf2.py", "type": "module"}, {"color": "#887600", "name": "unweighted", "size": 9.48074069840786, "docstring": "Shortest path algorithms for unweighted graphs.", "id": "unweighted", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/unweighted.py", "type": "module"}, {"color": "#20de00", "name": "isolate", "size": 4.732050807568877, "docstring": "Functions for identifying isolate (degree zero) nodes.", "id": "isolate", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isolate.py", "type": "module"}, {"color": "#5da100", "name": "test_current_flow_closeness", "size": 5.23606797749979, "docstring": "None", "id": "test_current_flow_closeness", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_current_flow_closeness.py", "type": "module"}, {"color": "#798500", "name": "test_maxflow_large_graph", "size": 7.0, "docstring": "Maximum flow algorithms test suite on large graphs.", "id": "test_maxflow_large_graph", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/tests/test_maxflow_large_graph.py", "type": "module"}, {"color": "#669800", "name": "isomorph", "size": 6.872983346207417, "docstring": "Graph isomorphism functions.", "id": "isomorph", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/isomorph.py", "type": "module"}, {"color": "#6a9400", "name": "test_attracting", "size": 5.0, "docstring": "None", "id": "test_attracting", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/tests/test_attracting.py", "type": "module"}, {"color": "#8e7000", "name": "generic", "size": 8.65685424949238, "docstring": "Compute the shortest paths and path lengths between nodes in the graph.\n\nThese algorithms work with undirected and directed graphs.", "id": "generic", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/generic.py", "type": "module"}, {"color": "#946a00", "name": "betweenness", "size": 9.6332495807108, "docstring": "Betweenness centrality measures.", "id": "betweenness", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/betweenness.py", "type": "module"}, {"color": "#857900", "name": "mixing", "size": 6.741657386773941, "docstring": "Mixing matrices for node attributes and degree.", "id": "mixing", "impno": 3, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/mixing.py", "type": "module"}, {"color": "#40be00", "name": "test_kclique", "size": 5.449489742783178, "docstring": "None", "id": "test_kclique", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/community/tests/test_kclique.py", "type": "module"}, {"color": "#827c00", "name": "test_all", "size": 4.414213562373095, "docstring": "None", "id": "test_all", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/tests/test_all.py", "type": "module"}, {"color": "#53ab00", "name": "closeness", "size": 5.82842712474619, "docstring": "Closeness centrality measures.", "id": "closeness", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/closeness.py", "type": "module"}, {"color": "#946a00", "name": "test_current_flow_betweenness_centrality", "size": 8.0, "docstring": "None", "id": "test_current_flow_betweenness_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_current_flow_betweenness_centrality.py", "type": "module"}, {"color": "#817d00", "name": "maxflow", "size": 7.47213595499958, "docstring": "Maximum flow (and minimum cut) algorithms on capacitated graphs.", "id": "maxflow", "impno": 5, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/maxflow.py", "type": "module"}, {"color": "#4eb000", "name": "test_vertex_cover", "size": 5.449489742783178, "docstring": "None", "id": "test_vertex_cover", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_vertex_cover.py", "type": "module"}, {"color": "#768800", "name": "dominance", "size": 7.0, "docstring": "Dominance algorithms.", "id": "dominance", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/dominance.py", "type": "module"}, {"color": "#00ff00", "name": "test_matching", "size": 4.0, "docstring": "None", "id": "test_matching", "impno": 8, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_matching.py", "type": "module"}, {"color": "#7b8300", "name": "current_flow_betweenness_subset", "size": 7.58257569495584, "docstring": "Current-flow betweenness centrality measures for subsets of nodes.", "id": "current_flow_betweenness_subset", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/current_flow_betweenness_subset.py", "type": "module"}, {"color": "#af4f00", "name": "test_project", "size": 6.464101615137754, "docstring": "None", "id": "test_project", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_project.py", "type": "module"}, {"color": "#8b7300", "name": "test_mixing", "size": 4.732050807568877, "docstring": "None", "id": "test_mixing", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/tests/test_mixing.py", "type": "module"}, {"color": "#837b00", "name": "edgelist", "size": 8.196152422706632, "docstring": "**********\nBipartite Edge Lists\n**********\nRead and write NetworkX graphs as bipartite edge lists.\n\nFormat\n------\nYou can read or write three formats of edge lists with these functions.\n\nNode pairs with no data::\n\n 1 2\n\nPython dictionary as data::\n\n 1 2 {'weight':7, 'color':'green'}\n\nArbitrary data::\n\n 1 2 7 green\n\nFor each edge (u, v) the node u is assigned to part 0 and the node v to part 1.", "id": "edgelist", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/edgelist.py", "type": "module"}, {"color": "#718d00", "name": "test_biconnected", "size": 5.449489742783178, "docstring": "None", "id": "test_biconnected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/tests/test_biconnected.py", "type": "module"}, {"color": "#00ff00", "name": "test_distance_measures", "size": 4.0, "docstring": "None", "id": "test_distance_measures", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_distance_measures.py", "type": "module"}, {"color": "#718d00", "name": "test_astar", "size": 7.0, "docstring": "None", "id": "test_astar", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/tests/test_astar.py", "type": "module"}, {"color": "#689600", "name": "test_load_centrality", "size": 7.123105625617661, "docstring": "None", "id": "test_load_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_load_centrality.py", "type": "module"}, {"color": "#3bc300", "name": "unary", "size": 5.645751311064591, "docstring": "Unary operations on graphs", "id": "unary", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/unary.py", "type": "module"}, {"color": "#54aa00", "name": "test_dense", "size": 4.732050807568877, "docstring": "None", "id": "test_dense", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/tests/test_dense.py", "type": "module"}, {"color": "#40be00", "name": "test_core", "size": 5.645751311064591, "docstring": "None", "id": "test_core", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_core.py", "type": "module"}, {"type": "module", "color": "#b54900", "name": "generators", "size": 12.055385138137417, "id": "generators", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/generators.py", "docstring": "Generators and functions for bipartite graphs."}, {"color": "#46b800", "name": "kclique", "size": 6.741657386773941, "docstring": "None", "id": "kclique", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/community/kclique.py", "type": "module"}, {"color": "#798500", "name": "test_connectivity", "size": 7.58257569495584, "docstring": "None", "id": "test_connectivity", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_connectivity.py", "type": "module"}, {"color": "#00ff00", "name": "test_swap", "size": 4.0, "docstring": "None", "id": "test_swap", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_swap.py", "type": "module"}, {"color": "#847a00", "name": "communicability_alg", "size": 6.60555127546399, "docstring": "Communicability and centrality measures.", "id": "communicability_alg", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/communicability_alg.py", "type": "module"}, {"color": "#976700", "name": "branchings", "size": 10.874007874011811, "docstring": "Algorithms for finding optimum branchings and spanning arborescences.\n\nThis implementation is based on:\n\n    J. Edmonds, Optimum branchings, J. Res. Natl. Bur. Standards 71B (1967),\n    233\u2013240. URL: http://archive.org/details/jresv71Bn4p233", "id": "branchings", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tree/branchings.py", "type": "module"}, {"color": "#48b600", "name": "spectral", "size": 5.449489742783178, "docstring": "Spectral bipartivity measure.", "id": "spectral", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/spectral.py", "type": "module"}, {"color": "#837b00", "name": "core", "size": 8.385164807134505, "docstring": "Find the k-cores of a graph.\n\nThe k-core is found by recursively pruning nodes with degrees less than k.\n\nSee the following reference for details:\n\nAn O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik, 2003.\nhttp://arxiv.org/abs/cs.DS/0310049", "id": "core", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/core.py", "type": "module"}, {"color": "#817d00", "name": "test_basic", "size": 5.645751311064591, "docstring": "None", "id": "test_basic", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_basic.py", "type": "module"}, {"color": "#6c9200", "name": "kcutsets", "size": 8.65685424949238, "docstring": "Kanevsky all minimum node k cutsets", "id": "kcutsets", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/kcutsets.py", "type": "module"}, {"color": "#996500", "name": "test_katz_centrality", "size": 8.567764362830022, "docstring": "None", "id": "test_katz_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_katz_centrality.py", "type": "module"}, {"type": "module", "color": "#847a00", "name": "edmondskarp", "size": 6.464101615137754, "id": "edmondskarp", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/edmondskarp.py", "docstring": "Edmonds-Karp algorithm for maximum flow problems."}, {"color": "#8a7400", "name": "hits_alg", "size": 8.477225575051662, "docstring": "Hubs and authorities analysis of graph structure.", "id": "hits_alg", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/link_analysis/hits_alg.py", "type": "module"}, {"color": "#5f9f00", "name": "test_dense_numpy", "size": 4.414213562373095, "docstring": "None", "id": "test_dense_numpy", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/tests/test_dense_numpy.py", "type": "module"}, {"type": "module", "color": "#13eb00", "name": "ramsey", "size": 4.414213562373095, "id": "ramsey", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/ramsey.py", "docstring": "Ramsey numbers."}, {"color": "#44ba00", "name": "vitality", "size": 5.82842712474619, "docstring": "Vitality measures.", "id": "vitality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/vitality.py", "type": "module"}, {"color": "#39c500", "name": "minors", "size": 6.464101615137754, "docstring": "Provides functions for computing minors of a graph.", "id": "minors", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/minors.py", "type": "module"}, {"color": "#52ac00", "name": "weakly_connected", "size": 6.3166247903554, "docstring": "Weakly connected components.", "id": "weakly_connected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/weakly_connected.py", "type": "module"}, {"color": "#00ff00", "name": "test_connected", "size": 4.732050807568877, "docstring": "None", "id": "test_connected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/tests/test_connected.py", "type": "module"}, {"color": "#659900", "name": "test_boundary", "size": 4.0, "docstring": "None", "id": "test_boundary", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_boundary.py", "type": "module"}, {"color": "#52ac00", "name": "test_hits", "size": 6.464101615137754, "docstring": "None", "id": "test_hits", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/link_analysis/tests/test_hits.py", "type": "module"}, {"color": "#728c00", "name": "test_stoer_wagner", "size": 4.732050807568877, "docstring": "None", "id": "test_stoer_wagner", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/tests/test_stoer_wagner.py", "type": "module"}, {"color": "#966800", "name": "test_simple_paths", "size": 7.795831523312719, "docstring": "None", "id": "test_simple_paths", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_simple_paths.py", "type": "module"}, {"color": "#4ab400", "name": "attracting", "size": 5.449489742783178, "docstring": "Attracting components.", "id": "attracting", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/attracting.py", "type": "module"}, {"type": "module", "color": "#38c600", "name": "clustering_coefficient", "size": 5.23606797749979, "id": "clustering_coefficient", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/clustering_coefficient.py", "docstring": "None"}, {"color": "#906e00", "name": "current_flow_betweenness", "size": 8.567764362830022, "docstring": "Current-flow betweenness centrality measures.", "id": "current_flow_betweenness", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/current_flow_betweenness.py", "type": "module"}, {"color": "#1de100", "name": "hierarchy", "size": 4.732050807568877, "docstring": "Flow Hierarchy.", "id": "hierarchy", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/hierarchy.py", "type": "module"}, {"color": "#738b00", "name": "test_degree_centrality", "size": 5.645751311064591, "docstring": "Unit tests for degree centrality.", "id": "test_degree_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_degree_centrality.py", "type": "module"}, {"color": "#38c600", "name": "neighbor_degree", "size": 5.449489742783178, "docstring": "None", "id": "neighbor_degree", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/neighbor_degree.py", "type": "module"}, {"color": "#5aa400", "name": "test_dominating_set", "size": 6.16227766016838, "docstring": "None", "id": "test_dominating_set", "impno": 8, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_dominating_set.py", "type": "module"}, {"color": "#8c7200", "name": "binary", "size": 8.65685424949238, "docstring": "Operations on graphs including union, intersection, difference.", "id": "binary", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/binary.py", "type": "module"}, {"color": "#00ff00", "name": "test_bfs", "size": 4.0, "docstring": "None", "id": "test_bfs", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/traversal/tests/test_bfs.py", "type": "module"}, {"color": "#7c8200", "name": "test_cluster", "size": 4.0, "docstring": "None", "id": "test_cluster", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_cluster.py", "type": "module"}, {"color": "#4ab400", "name": "redundancy", "size": 5.449489742783178, "docstring": "Node redundancy for bipartite graphs.", "id": "redundancy", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/redundancy.py", "type": "module"}, {"color": "#847a00", "name": "test_centrality", "size": 5.449489742783178, "docstring": "None", "id": "test_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_centrality.py", "type": "module"}, {"color": "#a55900", "name": "networksimplex", "size": 10.615773105863909, "docstring": "Minimum cost flow algorithms on directed connected graphs.", "id": "networksimplex", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/networksimplex.py", "type": "module"}, {"color": "#679700", "name": "dominating", "size": 6.16227766016838, "docstring": "None", "id": "dominating", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/dominating.py", "type": "module"}, {"color": "#946a00", "name": "cluster", "size": 8.8309518948453, "docstring": "Algorithms to characterize the number of triangles in a graph.", "id": "cluster", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/cluster.py", "type": "module"}, {"color": "#00ff00", "name": "test_ramsey", "size": 4.0, "docstring": "None", "id": "test_ramsey", "impno": 8, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_ramsey.py", "type": "module"}, {"color": "#4ab400", "name": "mincost", "size": 4.414213562373095, "docstring": "Minimum cost flow algorithms on directed connected graphs.", "id": "mincost", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/mincost.py", "type": "module"}, {"color": "#00ff00", "name": "test_smetric", "size": 4.0, "docstring": "None", "id": "test_smetric", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_smetric.py", "type": "module"}, {"color": "#817d00", "name": "betweenness_subset", "size": 8.099019513592784, "docstring": "Betweenness centrality measures for subsets of nodes.", "id": "betweenness_subset", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/betweenness_subset.py", "type": "module"}, {"color": "#00ff00", "name": "test_block", "size": 5.82842712474619, "docstring": "None", "id": "test_block", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_block.py", "type": "module"}, {"color": "#00ff00", "name": "test_current_flow_betweenness_centrality_subset", "size": 7.242640687119285, "docstring": "None", "id": "test_current_flow_betweenness_centrality_subset", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_current_flow_betweenness_centrality_subset.py", "type": "module"}, {"color": "#35c900", "name": "test_minors", "size": 4.732050807568877, "docstring": "Unit tests for the :mod:`networkx.algorithms.minors` module.", "id": "test_minors", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_minors.py", "type": "module"}, {"color": "#9b6300", "name": "test_betweenness_centrality_subset", "size": 7.123105625617661, "docstring": "None", "id": "test_betweenness_centrality_subset", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_betweenness_centrality_subset.py", "type": "module"}, {"color": "#2ed000", "name": "test_richclub", "size": 4.0, "docstring": "None", "id": "test_richclub", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_richclub.py", "type": "module"}, {"color": "#6f8f00", "name": "edgedfs", "size": 7.123105625617661, "docstring": "===========================\nDepth First Search on Edges\n===========================\n\nAlgorithms for a depth-first traversal of edges in a graph.", "id": "edgedfs", "impno": 0, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/traversal/edgedfs.py", "type": "module"}, {"color": "#00ff00", "name": "test_euler", "size": 5.82842712474619, "docstring": "None", "id": "test_euler", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_euler.py", "type": "module"}, {"color": "#00ff00", "name": "test_vitality", "size": 4.0, "docstring": "None", "id": "test_vitality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_vitality.py", "type": "module"}, {"color": "#a75700", "name": "test_coloring", "size": 7.242640687119285, "docstring": "Greedy coloring test suite.\n\nRun with nose: nosetests -v test_coloring.py", "id": "test_coloring", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/coloring/tests/test_coloring.py", "type": "module"}, {"color": "#a45a00", "name": "test_product", "size": 8.099019513592784, "docstring": "None", "id": "test_product", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/tests/test_product.py", "type": "module"}, {"color": "#6c9200", "name": "swap", "size": 7.58257569495584, "docstring": "Swap edges in a graph.", "id": "swap", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/swap.py", "type": "module"}, {"color": "#609e00", "name": "vf2userfunc", "size": 6.16227766016838, "docstring": "Module to simplify the specification of user-defined equality functions for\nnode and edge attributes during isomorphism checks.\n\nDuring the construction of an isomorphism, the algorithm considers two\ncandidate nodes n1 in G1 and n2 in G2.  The graphs G1 and G2 are then\ncompared with respect to properties involving n1 and n2, and if the outcome\nis good, then the candidate nodes are considered isomorphic. NetworkX\nprovides a simple mechanism for users to extend the comparisons to include\nnode and edge attributes.\n\nNode attributes are handled by the node_match keyword. When considering\nn1 and n2, the algorithm passes their node attribute dictionaries to\nnode_match, and if it returns False, then n1 and n2 cannot be\nconsidered to be isomorphic.\n\nEdge attributes are handled by the edge_match keyword. When considering\nn1 and n2, the algorithm must verify that outgoing edges from n1 are\ncommensurate with the outgoing edges for n2. If the graph is directed,\nthen a similar check is also performed for incoming edges.\n\nFocusing only on outgoing edges, we consider pairs of nodes (n1, v1) from\nG1 and (n2, v2) from G2. For graphs and digraphs, there is only one edge\nbetween (n1, v1) and only one edge between (n2, v2). Those edge attribute\ndictionaries are passed to edge_match, and if it returns False, then\nn1 and n2 cannot be considered isomorphic. For multigraphs and\nmultidigraphs, there can be multiple edges between (n1, v1) and also\nmultiple edges between (n2, v2).  Now, there must exist an isomorphism\nfrom \"all the edges between (n1, v1)\" to \"all the edges between (n2, v2)\".\nSo, all of the edge attribute dictionaries are passed to edge_match, and\nit must determine if there is an isomorphism between the two sets of edges.", "id": "vf2userfunc", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/vf2userfunc.py", "type": "module"}, {"type": "module", "color": "#4bb300", "name": "dominating_set", "size": 5.645751311064591, "id": "dominating_set", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/dominating_set.py", "docstring": "**************************************\nMinimum Vertex and Edge Dominating Set\n**************************************\n\n\nA dominating set for a graph G = (V, E) is a subset D of V such that every\nvertex not in D is joined to at least one member of D by some edge. The\ndomination number gamma(G) is the number of vertices in a smallest dominating\nset for G. Given a graph G = (V, E) find a minimum weight dominating set V'.\n\nhttp://en.wikipedia.org/wiki/Dominating_set\n\nAn edge dominating set for a graph G = (V, E) is a subset D of E such that\nevery edge not in D is adjacent to at least one edge in D.\n\nhttp://en.wikipedia.org/wiki/Edge_dominating_set"}, {"color": "#a95500", "name": "test_mincost", "size": 4.732050807568877, "docstring": "None", "id": "test_mincost", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/tests/test_mincost.py", "type": "module"}, {"color": "#7e8000", "name": "depth_first_search", "size": 7.58257569495584, "docstring": "==================\nDepth-first search\n==================\n\nBasic algorithms for depth-first searching the nodes of a graph.\n\nBased on http://www.ics.uci.edu/~eppstein/PADS/DFS.py\nby D. Eppstein, July 2004.", "id": "depth_first_search", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/traversal/depth_first_search.py", "type": "module"}, {"color": "#887600", "name": "cycles", "size": 9.48074069840786, "docstring": "========================\nCycle finding algorithms\n========================", "id": "cycles", "impno": 3, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/cycles.py", "type": "module"}, {"color": "#837b00", "name": "test_kcutsets", "size": 8.099019513592784, "docstring": "None", "id": "test_kcutsets", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/tests/test_kcutsets.py", "type": "module"}, {"type": "module", "color": "#8d7100", "name": "preflowpush", "size": 8.65685424949238, "id": "preflowpush", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/flow/preflowpush.py", "docstring": "Highest-label preflow-push algorithm for maximum flow problems."}, {"color": "#7e8000", "name": "test_pagerank", "size": 7.47213595499958, "docstring": "None", "id": "test_pagerank", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/link_analysis/tests/test_pagerank.py", "type": "module"}, {"color": "#837b00", "name": "test_generic", "size": 5.0, "docstring": "None", "id": "test_generic", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/tests/test_generic.py", "type": "module"}, {"color": "#53ab00", "name": "dense", "size": 6.3166247903554, "docstring": "Floyd-Warshall algorithm for shortest paths.", "id": "dense", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/dense.py", "type": "module"}, {"color": "#b14d00", "name": "test_betweenness_centrality", "size": 9.244997998398398, "docstring": "None", "id": "test_betweenness_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_betweenness_centrality.py", "type": "module"}, {"color": "#54aa00", "name": "astar", "size": 6.464101615137754, "docstring": "Shortest paths and path lengths using A* (\"A star\") algorithm.", "id": "astar", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/shortest_paths/astar.py", "type": "module"}, {"color": "#00ff00", "name": "test_weakly_connected", "size": 6.0, "docstring": "None", "id": "test_weakly_connected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/tests/test_weakly_connected.py", "type": "module"}, {"color": "#827c00", "name": "correlation", "size": 5.82842712474619, "docstring": "Node assortativity coefficients and correlation measures.", "id": "correlation", "impno": 3, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/correlation.py", "type": "module"}, {"color": "#00ff00", "name": "test_isomorphism", "size": 4.0, "docstring": "None", "id": "test_isomorphism", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/tests/test_isomorphism.py", "type": "module"}, {"color": "#649a00", "name": "test_recognition", "size": 4.732050807568877, "docstring": "None", "id": "test_recognition", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tree/tests/test_recognition.py", "type": "module"}, {"color": "#758900", "name": "basic", "size": 7.58257569495584, "docstring": "==========================\nBipartite Graph Algorithms\n==========================", "id": "basic", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/basic.py", "type": "module"}, {"color": "#00ff00", "name": "test_communicability", "size": 6.872983346207417, "docstring": "None", "id": "test_communicability", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_communicability.py", "type": "module"}, {"color": "#6f8f00", "name": "breadth_first_search", "size": 5.82842712474619, "docstring": "====================\nBreadth-first search\n====================\n\nBasic algorithms for breadth-first searching the nodes of a graph.", "id": "breadth_first_search", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/traversal/breadth_first_search.py", "type": "module"}, {"color": "#708e00", "name": "test_vf2userfunc", "size": 6.741657386773941, "docstring": "Tests for VF2 isomorphism algorithm for weighted graphs.", "id": "test_vf2userfunc", "impno": 4, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/tests/test_vf2userfunc.py", "type": "module"}, {"color": "#00ff00", "name": "test_independent_set", "size": 4.0, "docstring": "None", "id": "test_independent_set", "impno": 8, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/tests/test_independent_set.py", "type": "module"}, {"color": "#788600", "name": "test_dispersion", "size": 6.0, "docstring": "None", "id": "test_dispersion", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_dispersion.py", "type": "module"}, {"color": "#08f600", "name": "smetric", "size": 4.732050807568877, "docstring": "None", "id": "smetric", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/smetric.py", "type": "module"}, {"color": "#659900", "name": "distance_regular", "size": 7.358898943540674, "docstring": "=======================\nDistance-regular graphs\n=======================", "id": "distance_regular", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/distance_regular.py", "type": "module"}, {"type": "module", "color": "#00ff00", "name": "independent_set", "size": 4.0, "id": "independent_set", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/approximation/independent_set.py", "docstring": "Independent Set\n\nIndependent set or stable set is a set of vertices in a graph, no two of\nwhich are adjacent. That is, it is a set I of vertices such that for every\ntwo vertices in I, there is no edge connecting the two. Equivalently, each\nedge in the graph has at most one endpoint in I. The size of an independent\nset is the number of vertices it contains.\n\nA maximum independent set is a largest independent set for a given graph G\nand its size is denoted \u03b1(G). The problem of finding such a set is called\nthe maximum independent set problem and is an NP-hard optimization problem.\nAs such, it is unlikely that there exists an efficient algorithm for finding\na maximum independent set of a graph.\n\nhttp://en.wikipedia.org/wiki/Independent_set_(graph_theory)\n\nIndependent set algorithm is based on the following paper:\n\n`O(|V|/(log|V|)^2)` apx of maximum clique/independent set.\n\nBoppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.\ndoi:10.1007/BF01994876"}, {"color": "#936b00", "name": "chordal_alg", "size": 8.567764362830022, "docstring": "Algorithms for chordal graphs.\n\nA graph is chordal if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle).\nhttp://en.wikipedia.org/wiki/Chordal_graph", "id": "chordal_alg", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/chordal/chordal_alg.py", "type": "module"}, {"color": "#619d00", "name": "matrix", "size": 7.0, "docstring": "====================\nBiadjacency matrices\n====================", "id": "matrix", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/matrix.py", "type": "module"}, {"type": "module", "color": "#6e9000", "name": "flow_matrix", "size": 5.449489742783178, "id": "flow_matrix", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/flow_matrix.py", "docstring": "None"}, {"color": "#4bb300", "name": "current_flow_closeness", "size": 5.82842712474619, "docstring": "Current-flow closeness centrality measures.", "id": "current_flow_closeness", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/current_flow_closeness.py", "type": "module"}, {"type": "module", "color": "#639b00", "name": "utils", "size": 5.449489742783178, "id": "utils", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/utils.py", "docstring": "Utilities for connectivity package"}, {"color": "#a45a00", "name": "link_prediction", "size": 7.123105625617661, "docstring": "Link prediction algorithms.", "id": "link_prediction", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/link_prediction.py", "type": "module"}, {"color": "#49b500", "name": "block", "size": 6.464101615137754, "docstring": "Functions for creating network blockmodels from node partitions.\n\nCreated by Drew Conway <drew.conway@nyu.edu> \nCopyright (c) 2010. All rights reserved.", "id": "block", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/block.py", "type": "module"}, {"color": "#5f9f00", "name": "richclub", "size": 6.464101615137754, "docstring": "None", "id": "richclub", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/richclub.py", "type": "module"}, {"color": "#9f5f00", "name": "projection", "size": 9.928203230275509, "docstring": "One-mode (unipartite) projections of bipartite graphs.", "id": "projection", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/projection.py", "type": "module"}, {"color": "#936b00", "name": "strongly_connected", "size": 8.567764362830022, "docstring": "Strongly connected components.", "id": "strongly_connected", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/components/strongly_connected.py", "type": "module"}, {"color": "#867800", "name": "greedy_coloring", "size": 8.567764362830022, "docstring": "Greedy graph coloring using various strategies.", "id": "greedy_coloring", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/coloring/greedy_coloring.py", "type": "module"}, {"color": "#c23c00", "name": "test_link_prediction", "size": 4.0, "docstring": "None", "id": "test_link_prediction", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_link_prediction.py", "type": "module"}, {"color": "#53ab00", "name": "test_dfs", "size": 5.23606797749979, "docstring": "None", "id": "test_dfs", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/traversal/tests/test_dfs.py", "type": "module"}, {"type": "module", "color": "#00ff00", "name": "base_test", "size": 4.0, "id": "base_test", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/tests/base_test.py", "docstring": "None"}, {"color": "#699500", "name": "test_isomorphvf2", "size": 7.0, "docstring": "Tests for VF2 isomorphism algorithm.", "id": "test_isomorphvf2", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/tests/test_isomorphvf2.py", "type": "module"}, {"color": "#5ba300", "name": "stoerwagner", "size": 7.0, "docstring": "Stoer-Wagner minimum cut algorithm.", "id": "stoerwagner", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/stoerwagner.py", "type": "module"}, {"color": "#55a900", "name": "test_pairs", "size": 4.0, "docstring": "None", "id": "test_pairs", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/tests/test_pairs.py", "type": "module"}, {"color": "#54aa00", "name": "test_chordal", "size": 4.732050807568877, "docstring": "None", "id": "test_chordal", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/chordal/tests/test_chordal.py", "type": "module"}, {"color": "#966800", "name": "cuts", "size": 9.855654600401044, "docstring": "Flow based cut algorithms", "id": "cuts", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/connectivity/cuts.py", "type": "module"}, {"color": "#00ff00", "name": "all", "size": 5.449489742783178, "docstring": "Operations on many graphs.", "id": "all", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/all.py", "type": "module"}, {"color": "#46b800", "name": "harmonic", "size": 5.82842712474619, "docstring": "Harmonic centrality measure.", "id": "harmonic", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/harmonic.py", "type": "module"}, {"color": "#00ff00", "name": "test_hierarchy", "size": 4.0, "docstring": "None", "id": "test_hierarchy", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_hierarchy.py", "type": "module"}, {"color": "#00ff00", "name": "test_closeness_centrality", "size": 5.449489742783178, "docstring": "Tests for degree centrality.", "id": "test_closeness_centrality", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/tests/test_closeness_centrality.py", "type": "module"}, {"type": "module", "color": "#728c00", "name": "recognition", "size": 6.464101615137754, "id": "recognition", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tree/recognition.py", "docstring": "Recognition Tests\n=================\n\nA *forest* is an acyclic, undirected graph, and a *tree* is a connected forest.\nDepending on the subfield, there are various conventions for generalizing these\ndefinitions to directed graphs.\n\nIn one convention, directed variants of forest and tree are defined in an\nidentical manner, except that the direction of the edges is ignored. In effect,\neach directed edge is treated as a single undirected edge. Then, additional\nrestrictions are imposed to define *branchings* and *arborescences*.\n\nIn another convention, directed variants of forest and tree correspond to\nthe previous convention's branchings and arborescences, respectively. Then two\nnew terms, *polyforest* and *polytree*, are defined to correspond to the other\nconvention's forest and tree.\n\nSummarizing::\n\n   +-----------------------------+\n   | Convention A | Convention B |\n   +=============================+\n   | forest       | polyforest   |\n   | tree         | polytree     |\n   | branching    | forest       |\n   | arborescence | tree         |\n   +-----------------------------+\n\nEach convention has its reasons. The first convention emphasizes definitional\nsimilarity in that directed forests and trees are only concerned with\nacyclicity and do not have an in-degree constraint, just as their undirected\ncounterparts do not. The second convention emphasizes functional similarity\nin the sense that the directed analog of a spanning tree is a spanning\narborescence. That is, take any spanning tree and choose one node as the root.\nThen every edge is assigned a direction such there is a directed path from the\nroot to every other node. The result is a spanning arborescence.\n\nNetworkX follows convention \"A\". Explicitly, these are:\n\nundirected forest\n   An undirected graph with no undirected cycles.\n\nundirected tree\n   A connected, undirected forest.\n\ndirected forest\n   A directed graph with no undirected cycles. Equivalently, the underlying\n   graph structure (which ignores edge orientations) is an undirected forest.\n   In convention B, this is known as a polyforest.\n\ndirected tree\n   A weakly connected, directed forest. Equivalently, the underlying graph\n   structure (which ignores edge orientations) is an undirected tree. In\n   convention B, this is known as a polytree.\n\nbranching\n   A directed forest with each node having, at most, one parent. So the maximum\n   in-degree is equal to 1. In convention B, this is known as a forest.\n\narborescence\n   A directed tree with each node having, at most, one parent. So the maximum\n   in-degree is equal to 1. In convention B, this is known as a tree.\n\nFor trees and arborescences, the adjective \"spanning\" may be added to designate\nthat the graph, when considered as a forest/branching, consists of a single\ntree/arborescence that includes all nodes in the graph. It is true, by\ndefinition, that every tree/arborescence is spanning with respect to the nodes\nthat define the tree/arborescence and so, it might seem redundant to introduce\nthe notion of \"spanning\". However, the nodes may represent a subset of\nnodes from a larger graph, and it is in this context that the term \"spanning\"\nbecomes a useful notion."}, {"color": "#649a00", "name": "test_matrix", "size": 5.23606797749979, "docstring": "None", "id": "test_matrix", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/bipartite/tests/test_matrix.py", "type": "module"}, {"color": "#986600", "name": "pagerank_alg", "size": 9.32455532033676, "docstring": "PageRank analysis of graph structure. ", "id": "pagerank_alg", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/link_analysis/pagerank_alg.py", "type": "module"}, {"color": "#00ff00", "name": "test_edgedfs", "size": 4.0, "docstring": "None", "id": "test_edgedfs", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/traversal/tests/test_edgedfs.py", "type": "module"}, {"color": "#6e9000", "name": "pairs", "size": 7.0, "docstring": "Generators of  x-y pairs of node data.", "id": "pairs", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/pairs.py", "type": "module"}, {"color": "#a15d00", "name": "graphical", "size": 10.681145747868609, "docstring": "Test sequences for graphiness.", "id": "graphical", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/graphical.py", "type": "module"}, {"color": "#5ba300", "name": "euler", "size": 6.741657386773941, "docstring": "Eulerian circuits and graphs.", "id": "euler", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/euler.py", "type": "module"}, {"color": "#748a00", "name": "test_correlation", "size": 5.0, "docstring": "None", "id": "test_correlation", "impno": 3, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/tests/test_correlation.py", "type": "module"}, {"color": "#807e00", "name": "katz", "size": 7.795831523312719, "docstring": "Katz centrality.", "id": "katz", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/centrality/katz.py", "type": "module"}, {"color": "#4cb200", "name": "test_mis", "size": 5.449489742783178, "docstring": "Tests for maximal (not maximum) independent sets.", "id": "test_mis", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_mis.py", "type": "module"}, {"color": "#00ff00", "name": "test_neighbor_degree", "size": 4.0, "docstring": "None", "id": "test_neighbor_degree", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/assortativity/tests/test_neighbor_degree.py", "type": "module"}, {"color": "#a35b00", "name": "product", "size": 10.874007874011811, "docstring": "Graph products.", "id": "product", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/operators/product.py", "type": "module"}, {"type": "module", "color": "#b44a00", "name": "simple_paths", "size": 11.602325267042627, "id": "simple_paths", "impno": 2, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/simple_paths.py", "docstring": "None"}, {"color": "#887600", "name": "test_cycles", "size": 8.0, "docstring": "None", "id": "test_cycles", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/tests/test_cycles.py", "type": "module"}, {"type": "module", "color": "#827c00", "name": "matchhelpers", "size": 6.872983346207417, "id": "matchhelpers", "impno": 1, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/isomorphism/matchhelpers.py", "docstring": "Functions which help end users define customize node_match and\nedge_match functions to use during isomorphism checks."}, {"color": "#48b600", "name": "boundary", "size": 6.872983346207417, "docstring": "Routines to find the boundary of a set of nodes.\n\nEdge boundaries are edges that have only one end\nin the set of nodes.  \n\nNode boundaries are nodes outside the set of nodes\nthat have an edge to a node in the set.", "id": "boundary", "impno": 0, "filepath": "/home/camilo/Proyectos/networkx/networkx/algorithms/boundary.py", "type": "module"}]}